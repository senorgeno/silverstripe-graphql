<?php


namespace SilverStripe\GraphQL\Schema\Plugin;


use SilverStripe\Core\Config\Configurable;
use SilverStripe\Core\Injector\Injectable;
use SilverStripe\GraphQL\Schema\DataObject\DataObjectModel;
use SilverStripe\GraphQL\Schema\Exception\SchemaBuilderException;
use SilverStripe\GraphQL\Schema\Field\Field;
use SilverStripe\GraphQL\Schema\Field\ModelField;
use SilverStripe\GraphQL\Schema\Field\ModelQuery;
use SilverStripe\GraphQL\Schema\Field\Query;
use SilverStripe\GraphQL\Schema\Interfaces\QueryPlugin;
use SilverStripe\GraphQL\Schema\Schema;
use SilverStripe\GraphQL\Schema\Type\InputType;
use SilverStripe\GraphQL\Schema\Type\ModelType;

abstract class AbstractNestedInputPlugin implements QueryPlugin
{
    use Injectable;
    use Configurable;

    /**
     * @var InputType[]
     */
    protected $allTypes = [];

    /**
     * @var array
     */
    protected $fieldMapping = [];

    /**
     * @param Query $query
     * @param Schema $schema
     * @param array $config
     * @throws SchemaBuilderException
     */
    public function apply(Query $query, Schema $schema, array $config = []): void
    {
        // Leaky abstraction, but this is a very context-specific implementation and doesn't
        // warrant the creation of even more interfaces
        Schema::invariant(
            $query instanceof ModelQuery,
            'Cannot apply plugin %s to a query that is not generated by a model',
            static::class
        );
        /* @var ModelQuery $query */
        $model = $query->getModel();
        $typeName = $model->getTypeName();

        $configFields = $config['fields'] ?? Schema::ALL;

        $modelType = $schema->getModel($typeName);
        Schema::invariant(
            $modelType,
            'Could not find model for query that uses %s. Were plugins applied before the schema was done loading?',
            $typeName
        );
        $fieldName = $this->config()->get('field_name');

        if ($configFields === Schema::ALL) {
            $configFields = $this->buildAllFieldsConfig($modelType);
        }

        Schema::assertValidConfig($configFields);
        $fields = $this->buildInputTypeFields($modelType, $configFields);
        list ($allTypes) = $this->extractTypes($query, $modelType, $fields);
        $this->allTypes = $allTypes;

        $fieldGraph = $this->getFieldGraph($modelType, $fields);
        $pathMapping = $this->buildPathsFromFieldMapping($fieldGraph);
        $fieldMapping = [];
        foreach ($pathMapping as $fieldPath => $propPath) {
            if ($fieldPath !== $propPath) {
                $fieldMapping[$fieldPath] = $propPath;
            }
        }

        $this->fieldMapping = $fieldMapping;

        $query->addArg($fieldName, static::getTypeName($query, $modelType));

        foreach ($this->getAllTypes() as $inputType) {
            $schema->addType($inputType);
        }

        $query->addResolverMiddleware(
            $this->getResolver(),
            [
                'fieldMapping' => $fieldMapping,
                'fieldName' => $this->getFieldName(),
            ]
        );

    }


    /**
     * @param ModelType $modelType
     * @return array
     * @throws SchemaBuilderException
     */
    protected function buildAllFieldsConfig(ModelType $modelType): array
    {
        $filters = [];
        /* @var ModelField $fieldObj */
        foreach ($modelType->getFields() as $fieldObj) {
            $fieldName = $fieldObj->getPropertyName();
            if (!$modelType->getModel()->hasField($fieldName)) {
                continue;
            }
            if ($relatedModel = $fieldObj->getModelType()) {
                $filters[$fieldObj->getPropertyName()] = $this->buildAllFieldsConfig($relatedModel);
            } else {
                $filters[$fieldObj->getName()] = true;
            }
        }

        return $filters;
    }

    /**
     * @param ModelType|null $modelType
     * @param array $fields
     * @return array
     * @throws SchemaBuilderException
     */
    protected function buildInputTypeFields(ModelType $modelType, array $fields): array
    {
        $filters = [];
        foreach ($fields as $fieldName => $data) {
            if ($data === false) {
                continue;
            }
            /* @var ModelField $fieldObj */
            $fieldObj = $modelType->getFieldByName($fieldName);
            $relatedModel = $fieldObj->getModelType();
            if (!$this->shouldAddField($fieldObj, $modelType)) {
                continue;
            }
            if (is_array($data)) {
                Schema::invariant(
                    $relatedModel,
                    'Filter for field %s is declared as an array, but the field is not a nested object type',
                    $fieldName
                );
                $filters[$fieldName] = $this->buildInputTypeFields($relatedModel, $data);
            } else {
                if ($data === true) {
                    $fieldType = $fieldObj->getNamedType();
                    Schema::invariant(
                        !$relatedModel && in_array($fieldType, Schema::getInternalTypes()),
                        'Filter for field %s is declared as true, but the field is not a scalar type',
                        $fieldName
                    );
                    $filters[$fieldName] = static::getLeafNodeType($fieldType);
                }
            }
        }

        return $filters;
    }

    /**
     * @param Query $query
     * @param ModelType $modelType
     * @param array $filters
     * @param array $allTypes
     * @param array $parentStack
     * @return array
     * @throws SchemaBuilderException
     */
    protected function extractTypes(
        Query $query,
        ModelType $modelType,
        array $filters,
        array $allTypes = [],
        array $parentStack = []
    ): array {
        $fields = [];
        foreach ($filters as $fieldName => $data) {
            if (is_array($data)) {
                $parents = array_merge($parentStack, [$fieldName]);
                list($cumulativeTypes, $typeCreated) = $this->extractTypes(
                    $query,
                    $modelType,
                    $data,
                    $allTypes,
                    $parents
                );
                $allTypes = array_merge($allTypes, $cumulativeTypes);
                $fields[$fieldName] = $typeCreated;
            } else {
                $fields[$fieldName] = $data;
            }
        }
        $typeName = static::getTypeName($query, $modelType, $parentStack);
        $type = InputType::create($typeName)
            ->setFields($fields);
        $allTypes[] = $type;

        return [$allTypes, $typeName];
    }

    /**
     * @param ModelType|null $modelType
     * @param array $fields
     * @return array
     * @throws SchemaBuilderException
     */
    protected function getFieldGraph(ModelType $modelType, array $fields): array
    {
        $mapping = [];
        /* @var DataObjectModel $model */
        foreach ($fields as $fieldName => $typeOrArray) {
            /* @var ModelField $fieldObj */
            $fieldObj = $modelType->getFieldByName($fieldName);
            Schema::invariant(
                $fieldObj,
                'Could not map field %s',
                $fieldName
            );
            $isNested = is_array($typeOrArray);
            $class = $modelType->getModel()->getSourceClass();
            if ($isNested) {
                $relatedModel = $fieldObj->getModelType();
                Schema::invariant(
                    $relatedModel,
                    'Cannot find related model type for field %s',
                    $fieldName
                );
                $mapping[$fieldName] = [
                    'class' => $class,
                    'children' => $this->getFieldGraph($relatedModel, $typeOrArray)
                ];
            } else {
                $mapping[$fieldName] = [
                    'class' => $class,
                    'children' => null
                ];
            }
        }

        return $mapping;
    }


    /**
     * @param array $mapping
     * @param array $fieldOrigin
     * @param array $propOrigin
     * @return array
     */
    protected function buildPathsFromFieldMapping(
        array $mapping,
        array $fieldOrigin = [],
        array $propOrigin = []
    ): array {
        $allPaths = [];
        foreach ($mapping as $fieldName => $config) {
            $fieldPath = array_merge($fieldOrigin, [$fieldName]);
            $prop = static::getObjectProperty($config['class'], $fieldName);
            $propPath = array_merge($propOrigin, [$prop]);
            $children = $config['children'] ?? null;
            if (is_array($children)) {
                $allPaths = array_merge(
                    $allPaths,
                    $this->buildPathsFromFieldMapping($children, $fieldPath, $propPath)
                );
            } else {
                $allPaths[implode('.', $fieldPath)] = implode('.', $propPath);
            }
        }

        return $allPaths;
    }

    /**
     * @param string $class
     * @param string $fieldName
     * @return string
     */
    protected static function getObjectProperty(string $class, string $fieldName): string
    {
        return $fieldName;
    }

    /**
     * @param string $internalType
     * @return string
     */
    protected static function getLeafNodeType(string $internalType): string
    {
        return $internalType;
    }

    /**
     * @param array $argFilters
     * @param array $origin
     * @return array
     */
    public static function buildPathsFromArgs(array $argFilters, array $origin = []): array
    {
        $allPaths = [];
        foreach ($argFilters as $fieldName => $val) {
            $path = array_merge($origin, [$fieldName]);
            if (is_array($val)) {
                $allPaths = array_merge($allPaths, static::buildPathsFromArgs($val, $path));
            } else {
                $allPaths[implode('.', $path)] = $val;
            }
        }

        return $allPaths;
    }

    /**
     * @param ModelField $field
     * @param ModelType $modelType
     * @return bool
     */
    protected function shouldAddField(ModelField $field, ModelType $modelType): bool
    {
        return true;
    }

    /**
     * @return InputType[]
     */
    public function getAllTypes(): array
    {
        return $this->allTypes;
    }

    /**
     * @return array
     */
    public function getFieldMapping(): array
    {
        return $this->fieldMapping;
    }

    /**
     * @return string
     */
    abstract protected function getFieldName(): string;

    /**
     * @return array
     */
    abstract protected function getResolver(): array;

    /**
     * @param Query $query
     * @param ModelType $modelType
     * @param array $path
     * @return string
     */
    abstract public static function getTypeName(
        Query $query,
        ModelType $modelType,
        array $path = []
    ): string;
}
