<?php


namespace SilverStripe\GraphQL\Schema\DataObject\Plugin;


use SilverStripe\Core\Config\Configurable;
use SilverStripe\Core\Injector\Injector;
use SilverStripe\GraphQL\QueryFilter\FieldFilterInterface;
use SilverStripe\GraphQL\QueryFilter\FieldFilterRegistry;
use SilverStripe\GraphQL\QueryFilter\FilterRegistryInterface;
use SilverStripe\GraphQL\QueryFilter\ListFieldFilterInterface;
use SilverStripe\GraphQL\Schema\DataObject\DataObjectModel;
use SilverStripe\GraphQL\Schema\DataObject\InheritanceChain;
use SilverStripe\GraphQL\Schema\Exception\SchemaBuilderException;
use SilverStripe\GraphQL\Schema\Field\ModelField;
use SilverStripe\GraphQL\Schema\Field\ModelQuery;
use SilverStripe\GraphQL\Schema\Field\Query;
use SilverStripe\GraphQL\Schema\Interfaces\QueryPlugin;
use SilverStripe\GraphQL\Schema\Interfaces\SchemaUpdater;
use SilverStripe\GraphQL\Schema\Schema;
use SilverStripe\GraphQL\Schema\Type\InputType;
use SilverStripe\GraphQL\Schema\Type\ModelType;

class QueryFilter implements QueryPlugin, SchemaUpdater
{
    use Configurable;

    /**
     * @var array
     * @config
     */
    private static $dbfield_filters = [];

    /**
     * @var string
     * @config
     */
    private static $field_name = 'filter';

    /**
     * @return string
     */
    public function getIdentifier(): string
    {
        return 'dataobjectQueryFilter';
    }

    /**
     * Creates all the { eq: String, lte: String }, { eq: Int, lte: Int } etc types for comparisons
     * @param Schema $schema
     * @throws SchemaBuilderException
     */
    public static function updateSchemaOnce(Schema $schema): void
    {
        /* @var FieldFilterRegistry $registry */
        $registry = Injector::inst()->get(FilterRegistryInterface::class);
        $filters = $registry->getAll();
        if (empty($filters)) {
            return;
        }
        foreach (Schema::getInternalTypes() as $typeName) {
            $type = InputType::create(self::inputTypeName($typeName));
            foreach ($filters as $id => $filterInstance) {
                if ($filterInstance instanceof ListFieldFilterInterface) {
                    $type->addField($id, "[{$typeName}]");
                } else {
                    $type->addField($id, $typeName);
                }
            }
            $schema->addType($type);
        }
    }

    /**
     * @param Query $query
     * @param Schema $schema
     * @param array $config
     * @throws SchemaBuilderException
     */
    public function apply(Query $query, Schema $schema, array $config = []): void
    {
        // Leaky abstraction, but this is a very context-specific implementation and doesn't
        // warrant the creation of even more interfaces
        Schema::invariant(
            $query instanceof ModelQuery,
            'Cannot apply plugin %s to a query that is not generated by a model'
        );
        /* @var ModelQuery $query */
        Schema::invariant(
            $query->getModel() instanceof DataObjectModel,
            'Cannot apply plugin %s to a query that is not based on a DataObject'
        );

        /* @var DataObjectModel $model */
        $model = $query->getModel();
        $typeName = $model->getTypeName();

        $configFilters = $config['filters'] ?? Schema::ALL;

        $modelType = $schema->getModel($typeName);
        Schema::invariant(
            $modelType,
            'Could not find model for query that uses %s. Were plugins applied before the schema was done loading?',
            $typeName
        );

        if ($configFilters === Schema::ALL) {
            $configFilters = $this->buildAllFieldsMapping($modelType, $schema);
        }

        Schema::assertValidConfig($configFilters);
        $filters = $this->buildFilterMap($modelType, $configFilters);
        list ($rootType, $allTypes) = $this->extractTypes($query->getName(), $filters);
        foreach ($allTypes as $type) {
            $schema->addType($type);
        }

        $fieldName = $this->config()->get('field_name');
        $query->addArg($fieldName, $rootType);
    }

    /**
     * @param ModelType $modelType
     * @param Schema $schema
     * @return array
     * @throws SchemaBuilderException
     */
    private function buildAllFieldsMapping(ModelType $modelType, Schema $schema): array
    {
        $filters = [];
        /* @var ModelField $fieldObj */
        foreach ($modelType->getModel()->getAllFields() as $fieldName) {
            $fieldObj = $modelType->getFieldByName($fieldName);
            if (!$fieldObj) {
                continue;
            }
            if ($relatedModel = $fieldObj->getModelType()) {
                $filters[$fieldObj->getFieldName()] = $this->buildAllFieldsMapping(
                    $relatedModel,
                    $schema
                );
            } else {
                $filters[$fieldObj->getFieldName()] = true;
            }
        }

        return $filters;
    }

    /**
     * @param ModelType $modelType
     * @param array $fields
     * @return array
     * @throws SchemaBuilderException
     */
    private function buildFilterMap(ModelType $modelType, array $fields): array
    {
        $filters = [];
        foreach ($fields as $fieldName => $data) {
            if ($data === false) {
                continue;
            }
            /* @var ModelField $fieldObj */
            $fieldObj = $modelType->getFieldByName($fieldName);
            $relatedModel = $fieldObj->getModelType();
            if (is_array($data)) {
                Schema::invariant(
                    $relatedModel,
                    'Filter for field %s is declared as an array, but the field is not a nested object type',
                    $fieldName
                );
                $filters[$fieldName] = $this->buildFilterMap($relatedModel, $data);
            } else {
                if ($data === true) {
                    $fieldType = $fieldObj->getNamedType();
                    Schema::invariant(
                        !$relatedModel && in_array($fieldType, Schema::getInternalTypes()),
                        'Filter for field %s is declared as true, but the field is not a scalar type',
                        $fieldName
                    );
                    $filters[$fieldName] = self::inputTypeName($fieldType);
                }
            }
        }

        return $filters;
    }

    /**
     * @param string $queryName
     * @param array $filters
     * @param array $allTypes
     * @param string $parentName
     * @return array
     * @throws SchemaBuilderException
     */
    private function extractTypes(
        string $queryName,
        array $filters,
        array $allTypes = [],
        string $parentName = ''
    ): array {
        $fields = [];
        foreach ($filters as $fieldName => $data) {
            if (is_array($data)) {
                list($typeCreated, $cumulativeTypes) = $this->extractTypes($queryName, $data, $allTypes, $fieldName);
                $allTypes = array_merge($allTypes, $cumulativeTypes);
                $fields[$fieldName] = $typeCreated;
            } else {
                $fields[$fieldName] = $data;
            }
        }
        $typeName = sprintf('%s%sFilterFields', ucfirst($queryName), ucfirst($parentName));
        $type = InputType::create($typeName)
            ->setFields($fields);
        $allTypes[] = $type;

        return [$typeName, $allTypes];
    }

    /**
     * @param string $internalType
     * @return string
     */
    private static function inputTypeName(string $internalType): string
    {
        return sprintf('QueryFilter%sComparator', $internalType);
    }

}
