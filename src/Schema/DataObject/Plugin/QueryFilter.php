<?php


namespace SilverStripe\GraphQL\Schema\DataObject\Plugin;


use GraphQL\Type\Definition\ResolveInfo;
use SilverStripe\Core\Config\Configurable;
use SilverStripe\Core\Injector\Injector;
use SilverStripe\GraphQL\QueryFilter\FieldFilterRegistry;
use SilverStripe\GraphQL\QueryFilter\FilterRegistryInterface;
use SilverStripe\GraphQL\QueryFilter\ListFieldFilterInterface;
use SilverStripe\GraphQL\Schema\DataObject\DataObjectModel;
use SilverStripe\GraphQL\Schema\DataObject\FieldAccessor;
use SilverStripe\GraphQL\Schema\Exception\SchemaBuilderException;
use SilverStripe\GraphQL\Schema\Field\ModelField;
use SilverStripe\GraphQL\Schema\Field\ModelQuery;
use SilverStripe\GraphQL\Schema\Field\Query;
use SilverStripe\GraphQL\Schema\Interfaces\QueryPlugin;
use SilverStripe\GraphQL\Schema\Interfaces\SchemaUpdater;
use SilverStripe\GraphQL\Schema\Schema;
use SilverStripe\GraphQL\Schema\Type\InputType;
use SilverStripe\GraphQL\Schema\Type\ModelType;
use SilverStripe\ORM\DataList;
use SilverStripe\ORM\DataObject;

class QueryFilter implements QueryPlugin, SchemaUpdater
{
    use Configurable;

    const IDENTIFIER = 'dataobjectQueryFilter';

    /**
     * @var string
     * @config
     */
    private static $field_name = 'filter';

    /**
     * @return string
     */
    public function getIdentifier(): string
    {
        return self::IDENTIFIER;
    }

    /**
     * Creates all the { eq: String, lte: String }, { eq: Int, lte: Int } etc types for comparisons
     * @param Schema $schema
     * @throws SchemaBuilderException
     */
    public static function updateSchemaOnce(Schema $schema): void
    {
        /* @var FieldFilterRegistry $registry */
        $registry = Injector::inst()->get(FilterRegistryInterface::class);
        $filters = $registry->getAll();
        if (empty($filters)) {
            return;
        }
        foreach (Schema::getInternalTypes() as $typeName) {
            $type = InputType::create(self::inputTypeName($typeName));
            foreach ($filters as $id => $filterInstance) {
                if ($filterInstance instanceof ListFieldFilterInterface) {
                    $type->addField($id, "[{$typeName}]");
                } else {
                    $type->addField($id, $typeName);
                }
            }
            $schema->addType($type);
        }
    }

    /**
     * @param Query $query
     * @param Schema $schema
     * @param array $config
     * @throws SchemaBuilderException
     */
    public function apply(Query $query, Schema $schema, array $config = []): void
    {
        // Leaky abstraction, but this is a very context-specific implementation and doesn't
        // warrant the creation of even more interfaces
        Schema::invariant(
            $query instanceof ModelQuery,
            'Cannot apply plugin %s to a query that is not generated by a model'
        );
        /* @var ModelQuery $query */
        Schema::invariant(
            $query->getModel() instanceof DataObjectModel,
            'Cannot apply plugin %s to a query that is not based on a DataObject'
        );

        /* @var DataObjectModel $model */
        $model = $query->getModel();
        $typeName = $model->getTypeName();

        $configFilters = $config['filters'] ?? Schema::ALL;

        $modelType = $schema->getModel($typeName);
        Schema::invariant(
            $modelType,
            'Could not find model for query that uses %s. Were plugins applied before the schema was done loading?',
            $typeName
        );

        if ($configFilters === Schema::ALL) {
            $configFilters = $this->buildAllFieldsConfig($modelType, $schema);
        }

        Schema::assertValidConfig($configFilters);
        $fields = $this->buildInputTypeFields($modelType, $configFilters);
        list ($rootType, $allTypes) = $this->extractTypes($query->getName(), $fields);
        foreach ($allTypes as $type) {
            $schema->addType($type);
        }

        $fieldName = $this->config()->get('field_name');
        $query->addArg($fieldName, $rootType);

        $rawFieldMapping = $this->getFieldMapping($modelType, $fields);
        $pathMapping = self::buildPathsFromFieldMapping($rawFieldMapping);
        $fieldMapping = [];
        foreach ($pathMapping as $fieldPath => $propPath) {
            if ($fieldPath !== $propPath) {
                $fieldMapping[$fieldPath] = $propPath;
            }
        }

        $query->addResolverMiddleware(
            [static::class, 'filter'],
            [
                'fieldMapping' => $fieldMapping,
                'fieldName' => $fieldName,
            ]
        );
    }

    /**
     * @param ModelType $modelType
     * @param Schema $schema
     * @return array
     * @throws SchemaBuilderException
     */
    private function buildAllFieldsConfig(ModelType $modelType, Schema $schema): array
    {
        /* @var ModelField $fieldObj */
        foreach ($modelType->getFields() as $fieldObj) {
            $fieldName = $fieldObj->getPropertyName();
            if (!$modelType->getModel()->hasField($fieldName)) {
                continue;
            }
            if ($relatedModel = $fieldObj->getModelType()) {
                $filters[$fieldObj->getPropertyName()] = $this->buildAllFieldsConfig(
                    $relatedModel,
                    $schema
                );
            } else {
                $filters[$fieldObj->getName()] = true;
            }
        }

        return $filters;
    }

    /**
     * @param ModelType $modelType
     * @param array $fields
     * @return array
     * @throws SchemaBuilderException
     */
    private function buildInputTypeFields(ModelType $modelType, array $fields): array
    {
        $filters = [];
        foreach ($fields as $fieldName => $data) {
            if ($data === false) {
                continue;
            }
            /* @var ModelField $fieldObj */
            $fieldObj = $modelType->getFieldByName($fieldName);
            $relatedModel = $fieldObj->getModelType();
            if (is_array($data)) {
                Schema::invariant(
                    $relatedModel,
                    'Filter for field %s is declared as an array, but the field is not a nested object type',
                    $fieldName
                );
                $filters[$fieldName] = $this->buildInputTypeFields($relatedModel, $data);
            } else {
                if ($data === true) {
                    $fieldType = $fieldObj->getNamedType();
                    Schema::invariant(
                        !$relatedModel && in_array($fieldType, Schema::getInternalTypes()),
                        'Filter for field %s is declared as true, but the field is not a scalar type',
                        $fieldName
                    );
                    $filters[$fieldName] = self::inputTypeName($fieldType);
                }
            }
        }

        return $filters;
    }

    /**
     * @param string $queryName
     * @param array $filters
     * @param array $allTypes
     * @param string $parentName
     * @return array
     * @throws SchemaBuilderException
     */
    private function extractTypes(
        string $queryName,
        array $filters,
        array $allTypes = [],
        string $parentName = ''
    ): array {
        $fields = [];
        foreach ($filters as $fieldName => $data) {
            if (is_array($data)) {
                list($typeCreated, $cumulativeTypes) = $this->extractTypes($queryName, $data, $allTypes, $fieldName);
                $allTypes = array_merge($allTypes, $cumulativeTypes);
                $fields[$fieldName] = $typeCreated;
            } else {
                $fields[$fieldName] = $data;
            }
        }
        $typeName = sprintf('%s%sFilterFields', ucfirst($queryName), ucfirst($parentName));
        $type = InputType::create($typeName)
            ->setFields($fields);
        $allTypes[] = $type;

        return [$typeName, $allTypes];
    }

    /**
     * @param array $mapping
     * @param array $fieldOrigin
     * @param array $propOrigin
     * @return array
     */
    public static function buildPathsFromFieldMapping(
        array $mapping,
        array $fieldOrigin = [],
        array $propOrigin = []
    ): array {
        $allPaths = [];
        $fieldAccessor = FieldAccessor::singleton();
        foreach ($mapping as $fieldName => $config) {
            $fieldPath = array_merge($fieldOrigin, [$fieldName]);
            $sng = DataObject::singleton($config['class']);
            $prop = $fieldAccessor->normaliseField($sng, $fieldName);
            $propPath = array_merge($propOrigin, [$prop]);
            $children = $config['children'] ?? null;
            if (is_array($children)) {
                $allPaths = array_merge(
                    $allPaths,
                    static::buildPathsFromFieldMapping($children, $fieldPath, $propPath)
                );
            } else {
                $allPaths[implode('.', $fieldPath)] = implode('.', $propPath);
            }
        }

        return $allPaths;
    }

    public static function filter(array $context)
    {
        $mapping = $context['fieldMapping'] ?? [];
        $fieldName = $context['fieldName'];

        return function (DataList $list, array $args, array $context, ResolveInfo $info) use ($mapping, $fieldName) {
            $filterArgs = $args[$fieldName] ?? [];
            /* @var FilterRegistryInterface $registry */
            $registry = Injector::inst()->get(FilterRegistryInterface::class);
            $paths = static::buildPathsFromArgs($filterArgs);
            foreach ($paths as $path => $value) {
                $fieldParts = explode('.', $path);
                $filterID = array_pop($fieldParts);
                $fieldPath = implode('.', $fieldParts);
                $normalised = $mapping[$fieldPath] ?? $fieldPath;
                $filter = $registry->getFilterByIdentifier($filterID);
                if ($filter) {
                    $list = $filter->apply($list, $normalised, $value);
                }
            }

            return $list;
        };
    }

    /**
     * @param array $argFilters
     * @param array $origin
     * @return array
     */
    public static function buildPathsFromArgs(array $argFilters, array $origin = []): array
    {
        $allPaths = [];
        foreach ($argFilters as $fieldName => $val) {
            $path = array_merge($origin, [$fieldName]);
            if (is_array($val)) {
                $allPaths = array_merge($allPaths, static::buildPathsFromArgs($val, $path));
            } else {
                $allPaths[implode('.', $path)] = $val;
            }
        }

        return $allPaths;
    }

    /**
     * @param ModelType $modelType
     * @param array $filters
     * @return array
     * @throws SchemaBuilderException
     */
    private function getFieldMapping(ModelType $modelType, array $filters): array
    {
        $mapping = [];
        /* @var DataObjectModel $model */
        foreach ($filters as $fieldName => $typeOrArray) {
            /* @var ModelField $fieldObj */
            $fieldObj = $modelType->getFieldByName($fieldName);
            Schema::invariant(
                $fieldObj,
                'Could not map field %s',
                $fieldName
            );
            $isNested = is_array($typeOrArray);
            $class = $modelType->getModel()->getSourceClass();
            if ($isNested) {
                $relatedModel = $fieldObj->getModelType();
                Schema::invariant(
                    $relatedModel,
                    'Cannot find related model type for field %s',
                    $fieldName
                );
                $mapping[$fieldName] = [
                    'class' => $class,
                    'children' => $this->getFieldMapping($relatedModel, $typeOrArray)
                ];
            } else {
                $mapping[$fieldName] = [
                    'class' => $class,
                    'children' => null
                ];
            }
        }

        return $mapping;
    }

    /**
     * @param string $internalType
     * @return string
     */
    private static function inputTypeName(string $internalType): string
    {
        return sprintf('QueryFilter%sComparator', $internalType);
    }

}
